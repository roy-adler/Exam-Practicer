[
  {
    "id": "tf_2b_001",
    "q": "What is the primary purpose of Terraform state?",
    "choices": [
      "To store provider binaries",
      "To map real infrastructure resources to configuration and track metadata",
      "To replace version control history",
      "To hold only user outputs"
    ],
    "answer": [
      1
    ],
    "explain": "State maintains resource instances, attributes, and dependencies so Terraform can plan and apply changes accurately.",
    "tags": [
      "state",
      "purpose"
    ],
    "difficulty": "easy",
    "focus": "2b",
    "category": "Terraform State",
    "multiple": false
  },
  {
    "id": "tf_2b_002",
    "q": "Which of the following are benefits of remote state? (Select all that apply)",
    "choices": [
      "State locking to avoid concurrent applies",
      "Encryption at rest and access control",
      "Team collaboration with a shared source of truth",
      "Automatic rollback of failed applies without any configuration"
    ],
    "answer": [
      0,
      1,
      2
    ],
    "explain": "Backends like S3+DynamoDB, GCS, or Terraform Cloud offer locking, encryption, and collaboration. Rollback is not automatic.",
    "tags": [
      "remote-state",
      "locking",
      "security"
    ],
    "difficulty": "medium",
    "focus": "2b",
    "category": "Terraform State",
    "multiple": true
  },
  {
    "id": "tf_2b_003",
    "q": "Why does Terraform need to read state before planning?",
    "choices": [
      "To download modules",
      "To understand current resource instances and compute a correct diff against desired configuration",
      "To upgrade providers",
      "To validate credentials"
    ],
    "answer": [
      1
    ],
    "explain": "The plan compares desired configuration with what exists according to state and the provider APIs.",
    "tags": [
      "plan",
      "state",
      "diff"
    ],
    "difficulty": "easy",
    "focus": "2b",
    "category": "Terraform State",
    "multiple": false
  },
  {
    "id": "tf_2b_004",
    "q": "Which sensitive data can end up in state and therefore must be protected? (Select all that apply)",
    "choices": [
      "Provider credentials never appear in state",
      "Resource attributes like passwords or connection strings returned by providers",
      "Rendered values of variables and outputs",
      "Private keys generated by resources"
    ],
    "answer": [
      1,
      2,
      3
    ],
    "explain": "Providers often return sensitive attributes that are stored in state. Treat state as sensitive, encrypt and restrict access.",
    "tags": [
      "security",
      "sensitive",
      "state"
    ],
    "difficulty": "medium",
    "focus": "2b",
    "category": "Terraform State",
    "multiple": true
  },
  {
    "id": "tf_2b_005",
    "q": "What happens if you delete the state file but not the real resources?",
    "choices": [
      "Terraform automatically recreates state perfectly from the cloud",
      "Terraform may attempt to create resources again because it no longer knows they exist",
      "Nothing; terraform plan shows no changes",
      "Providers rebuild state with all historical metadata"
    ],
    "answer": [
      1
    ],
    "explain": "Without state, Terraform cannot correlate resources and may plan to create duplicates or destroy the wrong things after re\u2011import.",
    "tags": [
      "state-loss",
      "import"
    ],
    "difficulty": "medium",
    "focus": "2b",
    "category": "Terraform State",
    "multiple": false
  },
  {
    "id": "tf_2b_006",
    "q": "Which commands interact directly with state? (Select all that apply)",
    "choices": [
      "terraform state list",
      "terraform state mv",
      "terraform import",
      "terraform graph"
    ],
    "answer": [
      0,
      1,
      2
    ],
    "explain": "State subcommands read/mutate state; import adds resources to state. graph visualizes the dependency DAG but doesn\u2019t change state.",
    "tags": [
      "commands",
      "state"
    ],
    "difficulty": "easy",
    "focus": "2b",
    "category": "Terraform State",
    "multiple": true
  },
  {
    "id": "tf_2b_007",
    "q": "How does state improve performance of large configurations?",
    "choices": [
      "Stores a cache of resource attributes to avoid full scans of remote APIs on every plan",
      "Compiles Terraform to machine code",
      "Disables provider authentication",
      "Forces sequential execution only"
    ],
    "answer": [
      0
    ],
    "explain": "State caches attributes and the resource graph, reducing API calls during planning and apply.",
    "tags": [
      "performance",
      "state"
    ],
    "difficulty": "easy",
    "focus": "2b",
    "category": "Terraform State",
    "multiple": false
  },
  {
    "id": "tf_2b_008",
    "q": "Your team sees errors about simultaneous state operation. What is the likely missing configuration?",
    "choices": [
      "Backend encryption",
      "State locking (e.g., DynamoDB table for S3 backend)",
      "Module version pinning",
      "Workspaces"
    ],
    "answer": [
      1
    ],
    "explain": "Locking prevents concurrent changes. Backends like S3 need a DynamoDB table configured for locks.",
    "tags": [
      "locking",
      "s3",
      "backend"
    ],
    "difficulty": "medium",
    "focus": "2b",
    "category": "Terraform State",
    "multiple": false
  },
  {
    "id": "tf_2b_009",
    "q": "Why might you split state into multiple state files (e.g., per stack or environment)? (Select all that apply)",
    "choices": [
      "Reduce blast radius of changes",
      "Improve plan/apply times",
      "Delegate ownership/access by team",
      "Because Terraform cannot handle more than 50 resources"
    ],
    "answer": [
      0,
      1,
      2
    ],
    "explain": "Smaller, domain\u2011based states can be faster and safer with clearer ownership. There is no hard 50\u2011resource limit.",
    "tags": [
      "state-split",
      "teams",
      "performance"
    ],
    "difficulty": "medium",
    "focus": "2b",
    "category": "Terraform State",
    "multiple": true
  },
  {
    "id": "tf_2b_010",
    "q": "Which statements about workspaces and state are true? (Select all that apply)",
    "choices": [
      "Each workspace maintains a separate state snapshot for the same configuration",
      "Workspaces are interchangeable with Git branches",
      "Workspaces are useful for environment separation when resources are similar",
      "Changing workspace changes the backend configuration automatically"
    ],
    "answer": [
      0,
      2
    ],
    "explain": "Workspaces keep separate state for the same code and are handy for env separation. They are not Git branches and don\u2019t auto\u2011change backend settings.",
    "tags": [
      "workspaces",
      "state"
    ],
    "difficulty": "medium",
    "focus": "2b",
    "category": "Terraform State",
    "multiple": true
  },
  {
    "id": "tf_2b_011",
    "q": "Which backend features directly contribute to state security? (Select all that apply)",
    "choices": [
      "Server\u2011side encryption (SSE) or KMS\u2011based encryption",
      "Access policies/ACLs restricting who can read state",
      "Versioning and retention to recover from corruption",
      "Local caches of provider binaries"
    ],
    "answer": [
      0,
      1,
      2
    ],
    "explain": "Encrypt state, restrict access, and use versioning/retention. Provider binaries are unrelated to state security.",
    "tags": [
      "security",
      "backend",
      "kms"
    ],
    "difficulty": "easy",
    "focus": "2b",
    "category": "Terraform State",
    "multiple": true
  }
]